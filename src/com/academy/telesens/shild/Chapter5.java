package com.academy.telesens.shild;

public class Chapter5 {
    //массивы


    public static void main(String[] args) {
        //Демонстрация одномерного массива

 /*       int[] sample = new int [10];
        int i;

        for(i = 0; i < 10; i = i + 1)//индексация массивов начинается с нуля
            sample[i] = i;
        for(i = 0;i < 10; i = i+1)//индексация массивов начинается с нуля
            System.out.println("Элемент[" + i + "]: " + sample[i]);
        Элемент[0]: 0
        Элемент[1]: 1
        Элемент[2]: 2
        Элемент[3]: 3
        Элемент[4]: 4
        Элемент[5]: 5
        Элемент[6]: 6
        Элемент[7]: 7
        Элемент[8]: 8
        Элемент[9]: 9  */
//*******************************************************************

 /*       Нахождение минимального и максимального значения в массиве
        1 variant

        int nums[] = new int[10];
        int min, max;
        nums[0] = 99;
        nums[1] = -10;
        nums[2] = 100123;
        nums[4] = 18;
        nums[5] = -978;
        nums[6] = 463;
        nums[7] = -9;
        nums[8] = 287;
        nums[9] = 49;
        min = max = nums[0];
        for(int i = 1; i < 10; i++) {
            if (nums[i] < min) min = nums[i];
            if (nums[i] > max) max = nums[i];
            System.out.println("min and max: " + min + " " + max);

//            min and max: -10 99
//            min and max: -10 100123
//            min and max: -10 100123
//            min and max: -10 100123
//            min and max: -978 100123
//            min and max: -978 100123
//            min and max: -978 100123
//            min and max: -978 100123
//            min and max: -978 100123
//        }
//****************************************************************
            //2variant
        int[] nums = { 99, -10,  100123, 18, -978, 5623,
                463, -9, 287, 49};//инициализация массива
        int min, max;

        min = max = nums[0];
        for(int i = 1; i < 10; i++) {
            if (nums[i] < min) min = nums[i];
            if (nums[i] > max) max = nums[i];
            System.out.println("min and max: " + min + " " + max);
        }

        //min and max: -978 100123

//*********************************************************
        //Демонстрация превышенния границ массива
        int[] sample = new int[10];
        int i;

        //искусственно сщздать выход индекса за границы массива
        for(i = 0; i < 100; i++)
            sample[i] = i;
//Как только значение переменной i достигнет 10, будет сгенерировано исключение
//ArrayindexOutOfBoundsException, и выполнение программы прекратится.

//********************************************************************

       // Exercise 5.1 Сортировка массива

        //Пример реализации алгоритма пузырьковой сортировки
/*
        for(a = 1; a < size; a++)//Внешний цикл обеспечивает
            // повторение описанного процесса до завершения
            // всего процесса сортировки.

            for(b = size-1; b >= a; b--).
                if(nums[b-1] > nums[b]){//Во внутреннем цикле сравниваются
                    // соседние элементы
                    // если требуемый порядок следования
                    // не соблюдается, поменять элементы
                    // местами

                    t = nums[b-1];
                    nums[b-1] = nums[b];
                    nums[b] = t;
                }
         }
  */      //**********************************
 /*       //Демонстрация алгоритма пузырьковой сортировки

        int[] nums = { 99, -10,  100123, 18, -978, 5623,
                463, -9, 287, 49};//инициализация массива
        int a, b, t;
        int size;

        size = 10; //колличество сортируемых элементов

        //отобразить исходный массив
        System.out.print("Исходный массив");
        for (int i = 0; i < size; i++)
            System.out.println(" " + nums[i]);
//        100123
//        18
//                -978
//        5623
//        463
//                -9
//        287
//        49
        System.out.println();
        //Реализовать алгоритм пузырьковой сортировки
        for(a = 1; a < size; a++)//Внешний цикл обеспечивает
            // повторение описанного процесса до завершения
            // всего процесса сортировки.

            for(b = size-1; b >= a; b--){
        if(nums[b-1] > nums[b]){//Во внутреннем цикле сравниваются
            // соседние элементы
            // если требуемый порядок следования
            // не соблюдается, поменять элементы
            // местами

            t = nums[b-1];
            nums[b-1] = nums[b];
            nums[b] = t;
        }
    }
        //Отобразить отсортированный массив
        System.out.print("Oтcopтиpoвaнный массив:");
        for(int i = 0; i < size; i++)
            System.out.print(" " + nums[i]);
        System.out.println();
 //       Oтcopтиpoвaнный массив: -978 -10 -9 18 49 99 287 463 5623 100123*/

 //**************************************************************************
        //Демонстрация использования двухмерного массива
        int t, i;
        int[][] table  = new int [3][4];
        for (t = 0; t < 3; ++t) {
            for(i = 0; i < 4; ++i) {
                table[t][i] = (t*4) + i +1;
                System.out.println(table [t][i] + " ");
            }
            System.out.println();
        }

       /* В данном примере элемент tаЫе [О] [О] будет содержать значение 1, элемент
        tаЫе[О] [1] - значение 2, элемент taЫe[OJ [21 - значение 3 и так далее, а элемент
        tаЫе [2 J [3 J - значение 12. Структура данного массива представлена в наглядном виде
        на рис. 5.1.*/



  }
}
